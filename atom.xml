<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gohna</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gohna/gohna.github.io.git/"/>
  <updated>2018-11-09T12:12:05.715Z</updated>
  <id>http://gohna/gohna.github.io.git/</id>
  
  <author>
    <name>gohna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hadoop伪分布式环境配置“</title>
    <link href="http://gohna/gohna.github.io.git/2018/11/09/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E2%80%9C/"/>
    <id>http://gohna/gohna.github.io.git/2018/11/09/Hadoop伪分布式环境配置“/</id>
    <published>2018-11-09T12:12:05.000Z</published>
    <updated>2018-11-09T12:12:05.715Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编译Linux内核</title>
    <link href="http://gohna/gohna.github.io.git/2018/11/09/%E7%BC%96%E8%AF%91Linux%E5%86%85%E6%A0%B8/"/>
    <id>http://gohna/gohna.github.io.git/2018/11/09/编译Linux内核/</id>
    <published>2018-11-09T07:37:15.000Z</published>
    <updated>2018-11-09T12:14:08.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><font face="微软雅黑">前言</font></h2><ul><li>本文主要介绍编译Linux内核实验的相关知识点和基本操作教程  </li><li>本文使用的虚拟机是VMware WorkStation，使用的操作系统是CentOS-7-X86_64，重新编译的内核是，以上均可在官网上下载获得。也可使用其他版本完成此实验，若使用其他版本，可能会出现一些小的问题不能完全贴合此教程。欢迎大家参照其他教程完成实验或者发邮件给我一起讨论解决。</li></ul><h2 id="本文框架"><a href="#本文框架" class="headerlink" title="本文框架"></a><font face="微软雅黑">本文框架</font></h2><p><img src="/gohna.github.io.git/2018/11/09/编译Linux内核/编译Linux内核.jpg" alt="Mindmap-本文框架"></p><h2 id="理论解释"><a href="#理论解释" class="headerlink" title="理论解释"></a><font face="微软雅黑">理论解释</font></h2><blockquote><p>Linux操作系统是一个开源的操作系统，我们可以从网上获取到Linux操作系统的内核源代码，并对这些代码进行编译，生成一个新内核的二进制文件，然后我们将生成的二进制文件跑起来，这就是我们这个实验的主要思路。  </p></blockquote><ul><li>内核是操作系统的内部核心程序，它向外部提供了对计算机设备的核心管理调用。    </li><li>内核由两个明显的接口，上层是系统调用接口，下层是面向硬件部分的接口，在这之间的就是内核部分。 后续我们拿到内核编译代码也可以看到，它的代码也是以这种结构来组织的。</li><li>make是一个可以对大型程序自己决定需要编译的代码块并且自动发起命令编译工具。Linux中make为GNUmake。其他平台也有相应的make，比如集成开发环境IDE，只需在菜单上点击rebuild/recompare，就可以重新编译/重新构造二进制文件，并且它可以自己决定哪些源码改动过了需要重新编译，哪些源码没有改动过不需要重新编译。</li><li>本实验涉及到的一些make操作及其含义：make mennuconfig：用命令行模式配置内核。make：编译内核和模块。make modules_install：安装模块。make install：安装内核。make mrproper：清楚之前做的一些关于内核编译的操作。</li><li>makefile是一个文件数据库，其中定义了一些如何重新编译系统的规则和方法。</li><li>操作系统引导过程：<ol><li>电脑开机后，开始启动BIOS，开始BIOS自检。  </li><li>通过自检后，BIOS找到硬盘上的主引导记录MBR。</li><li>MBR开始读取硬盘分区表DPT，找到活动分区中的分区引导记录PBR，并且把控制权交给PBR。</li><li>PBR搜索活动分区中的启动管理器boomtmgr，把控制权交给bootmgr（相当于xp里的ntldr文件）。</li><li>Boomtgr寻找BOOT文件夹中的BCD文件（启动配置数据，相当于xp里的boot.ini文件）。</li><li>找到BCD后，Bootmgr首先从BCD中读取启动管理器bootmgr菜单信息，在显示器上显示多操作系统选择画面。</li><li>如果存在多个操作系统而且系统设置的等待时间不是0，那么屏幕就显示多个操作系统的选择界面。如果没有多系统，那么直接进入系统，不显示选择界面。</li><li>选择系统（如win7）后，bootmgr就会读取BCD里win7系统所在的盘里的windows\system32\winload.exe文件，并将控制权交给winload.exe。</li><li>Winload.exe加载win7内核、硬件、服务等，之后加载桌面等信息，从而启动整个win7系统。  </li></ol></li><li>Linux下的启动管理器有LILO/GRUB/yaboot，由于配置文件错误造成Linux启动失败时可以用grub程序的相关命令手动启动Linux。（编译结束重启时可能会用到）  </li></ul><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a><font face="微软雅黑">操作流程</font></h2><p><img src="/gohna.github.io.git/2018/11/09/编译Linux内核/B2.png" alt="Mindmap-操作流程"></p><h2 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a><font face="微软雅黑">实验小结</font></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;font face=&quot;微软雅黑&quot;&gt;前言&lt;/font&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本文主要介绍编译Linux内核实验的相关知识点和基本操作教程  &lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://gohna/gohna.github.io.git/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://gohna/gohna.github.io.git/tags/Linux/"/>
    
  </entry>
  
</feed>
